name: monthly-pi-sync

on:
  workflow_dispatch:  # manual trigger only
  schedule:
    - cron: '0 4 1 * *'

jobs:
  sync-to-pi:
    runs-on: ubuntu-latest
    timeout-minutes: 120

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Connect to Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci
          version: latest
          ping: ${{ secrets.PI_HOST }}

      - name: Set up SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PI_SSH_KEY }}" > ~/.ssh/pi_key
          chmod 600 ~/.ssh/pi_key
          ssh-keyscan -H ${{ secrets.PI_HOST }} >> ~/.ssh/known_hosts

      - name: Export MotherDuck to local .db file
        env:
          MOTHERDUCK_TOKEN: ${{ secrets.MOTHERDUCK_TOKEN }}
        run: |
          python - <<'EOF'
          import duckdb
          import os
          from datetime import datetime

          timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
          output_file = f"/tmp/TMDB_{timestamp}.db"

          print(f"Connecting to MotherDuck...")
          conn = duckdb.connect()
          conn.execute("ATTACH 'md:TMDB' AS TMDB")
          conn.execute(f"ATTACH '{output_file}' AS local_db")

          tables = conn.execute("""
              SELECT table_name
              FROM information_schema.tables
              WHERE table_schema = 'main'
              AND table_catalog = 'TMDB'
          """).fetchall()

          print(f"Exporting {len(tables)} tables...")
          for table in tables:
              name = table[0]
              conn.execute(f'CREATE OR REPLACE TABLE local_db.main."{name}" AS SELECT * FROM TMDB.main."{name}"')
              count = conn.execute(f'SELECT COUNT(*) FROM local_db.main."{name}"').fetchone()[0]
              print(f"  ✓ {name}: {count:,} rows")

          conn.close()

          # Write filename to file so next step can read it
          with open("/tmp/db_filename.txt", "w") as f:
              f.write(output_file)

          print(f"\nExport complete: {output_file}")
          size_mb = os.path.getsize(output_file) / (1024 * 1024)
          print(f"File size: {size_mb:.1f} MB")
          EOF

      - name: Create target directory on Pi
        run: |
          ssh -i ~/.ssh/pi_key -o StrictHostKeyChecking=no \
            ${{ secrets.PI_USER }}@${{ secrets.PI_HOST }} \
            "mkdir -p ~/tmdb_data"

      - name: Copy .db file to Pi
        run: |
          DB_FILE=$(cat /tmp/db_filename.txt)
          echo "Copying $DB_FILE to Pi..."
          scp -i ~/.ssh/pi_key -o StrictHostKeyChecking=no \
            "$DB_FILE" \
            ${{ secrets.PI_USER }}@${{ secrets.PI_HOST }}:~/tmdb_data/TMDB_latest.db
          echo "✓ Copy complete"

      - name: Verify file on Pi and clean up old files
        run: |
          ssh -i ~/.ssh/pi_key -o StrictHostKeyChecking=no \
            ${{ secrets.PI_USER }}@${{ secrets.PI_HOST }} << 'ENDSSH'
            echo "Files in ~/tmdb_data:"
            ls -lh ~/tmdb_data/
            echo ""
            echo "Disk usage:"
            df -h ~/tmdb_data/
          ENDSSH
